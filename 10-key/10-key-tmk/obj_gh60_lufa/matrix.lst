   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB18:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #   define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // initialize row and col
  61:matrix.c      ****     unselect_rows();
  62:matrix.c      ****     init_cols();
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize matrix state: all keys off
  65:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  66:matrix.c      ****         matrix[i] = 0;
  67:matrix.c      ****         matrix_debouncing[i] = 0;
  68:matrix.c      ****     }
  69:matrix.c      **** }
  70:matrix.c      **** 
  71:matrix.c      **** uint8_t matrix_scan(void)
  72:matrix.c      **** {
  73:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  74:matrix.c      ****         select_row(i);
  75:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  76:matrix.c      ****         matrix_row_t cols = read_cols();
  77:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  78:matrix.c      ****             matrix_debouncing[i] = cols;
  79:matrix.c      ****             if (debouncing) {
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  81:matrix.c      ****             }
  82:matrix.c      ****             debouncing = DEBOUNCE;
  83:matrix.c      ****         }
  84:matrix.c      ****         unselect_rows();
  85:matrix.c      ****     }
  86:matrix.c      **** 
  87:matrix.c      ****     if (debouncing) {
  88:matrix.c      ****         if (--debouncing) {
  89:matrix.c      ****             _delay_ms(1);
  90:matrix.c      ****         } else {
  91:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  92:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  93:matrix.c      ****             }
  94:matrix.c      ****         }
  95:matrix.c      ****     }
  96:matrix.c      **** 
  97:matrix.c      ****     return 1;
  98:matrix.c      **** }
  99:matrix.c      **** 
 100:matrix.c      **** bool matrix_is_modified(void)
 101:matrix.c      **** {
 102:matrix.c      ****     if (debouncing) return false;
 103:matrix.c      ****     return true;
 104:matrix.c      **** }
 105:matrix.c      **** 
 106:matrix.c      **** inline
 107:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 108:matrix.c      **** {
 109:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 110:matrix.c      **** }
 111:matrix.c      **** 
 112:matrix.c      **** inline
 113:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 114:matrix.c      **** {
 115:matrix.c      ****     return matrix[row];
 116:matrix.c      **** }
 117:matrix.c      **** 
 118:matrix.c      **** void matrix_print(void)
 119:matrix.c      **** {
 120:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 121:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 122:matrix.c      ****         phex(row); print(": ");
 123:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 124:matrix.c      ****         print("\n");
 125:matrix.c      ****     }
 126:matrix.c      **** }
 127:matrix.c      **** 
 128:matrix.c      **** uint8_t matrix_key_count(void)
 129:matrix.c      **** {
 130:matrix.c      ****     uint8_t count = 0;
 131:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 132:matrix.c      ****         count += bitpop16(matrix[i]);
 133:matrix.c      ****     }
 134:matrix.c      ****     return count;
 135:matrix.c      **** }
 136:matrix.c      **** 
 137:matrix.c      **** /* Column pin configuration
 138:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   10  11  12  13
 139:matrix.c      ****  * pin: F0  F1  E6  C7  C6  B6  D4  B1  B0  B5  B4  D7  D6  B3  (Rev.A)
 140:matrix.c      ****  * pin:                                 B7                      (Rev.B)
 141:matrix.c      ****  */
 142:matrix.c      **** static void  init_cols(void)
 143:matrix.c      **** {
 144:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 145:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<5 | 1<<3 | 1<<4);
 146:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<5 | 1<<3 | 1<<4);
 147:matrix.c      **** }
 148:matrix.c      **** 
 149:matrix.c      **** static matrix_row_t read_cols(void)
 150:matrix.c      **** {
 151:matrix.c      ****     return (PINB&(1<<0) ? 0 : (1<<0)) |
 152:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<1)) |
 153:matrix.c      ****            (PINB&(1<<5) ? 0 : (1<<2)) |
 154:matrix.c      ****            (PINB&(1<<3) ? 0 : (1<<3)) |
 155:matrix.c      ****            (PINB&(1<<4) ? 0 : (1<<4));
 156:matrix.c      **** }
 157:matrix.c      **** 
 158:matrix.c      **** /* Row pin configuration
 159:matrix.c      ****  * row: 0   1   2   3   4
 160:matrix.c      ****  * pin: D0  D1  D2  D3  D5
 161:matrix.c      ****  */
 162:matrix.c      **** static void unselect_rows(void)
 163:matrix.c      **** {
  15               		.loc 1 163 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 164:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 165:matrix.c      ****     DDRD  &= ~0b00011111;
  21               		.loc 1 165 0
  22 0000 8AB1      		in r24,0xa
  23 0002 807E      		andi r24,lo8(-32)
  24 0004 8AB9      		out 0xa,r24
 166:matrix.c      ****     PORTD &= ~0b00011111;
  25               		.loc 1 166 0
  26 0006 8BB1      		in r24,0xb
  27 0008 807E      		andi r24,lo8(-32)
  28 000a 8BB9      		out 0xb,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE18:
  33               		.section	.text.matrix_rows,"ax",@progbits
  34               	.global	matrix_rows
  36               	matrix_rows:
  37               	.LFB7:
  48:matrix.c      ****     return MATRIX_ROWS;
  38               		.loc 1 48 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
  50:matrix.c      **** 
  44               		.loc 1 50 0
  45 0000 85E0      		ldi r24,lo8(5)
  46 0002 0895      		ret
  47               		.cfi_endproc
  48               	.LFE7:
  50               		.section	.text.matrix_cols,"ax",@progbits
  51               	.global	matrix_cols
  53               	matrix_cols:
  54               	.LFB8:
  54:matrix.c      ****     return MATRIX_COLS;
  55               		.loc 1 54 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  56:matrix.c      **** 
  61               		.loc 1 56 0
  62 0000 85E0      		ldi r24,lo8(5)
  63 0002 0895      		ret
  64               		.cfi_endproc
  65               	.LFE8:
  67               		.section	.text.matrix_init,"ax",@progbits
  68               	.global	matrix_init
  70               	matrix_init:
  71               	.LFB9:
  59:matrix.c      ****     // initialize row and col
  72               		.loc 1 59 0
  73               		.cfi_startproc
  74               	/* prologue: function */
  75               	/* frame size = 0 */
  76               	/* stack size = 0 */
  77               	.L__stack_usage = 0
  61:matrix.c      ****     init_cols();
  78               		.loc 1 61 0
  79 0000 0E94 0000 		call unselect_rows
  80               	.LVL0:
  81               	.LBB23:
  82               	.LBB24:
 145:matrix.c      ****     PORTB |=  (1<<0 | 1<<1 | 1<<5 | 1<<3 | 1<<4);
  83               		.loc 1 145 0
  84 0004 84B1      		in r24,0x4
  85 0006 847C      		andi r24,lo8(-60)
  86 0008 84B9      		out 0x4,r24
 146:matrix.c      **** }
  87               		.loc 1 146 0
  88 000a 85B1      		in r24,0x5
  89 000c 8B63      		ori r24,lo8(59)
  90 000e 85B9      		out 0x5,r24
  91               	.LVL1:
  92 0010 A0E0      		ldi r26,lo8(matrix_debouncing)
  93 0012 B0E0      		ldi r27,hi8(matrix_debouncing)
  94 0014 E0E0      		ldi r30,lo8(matrix)
  95 0016 F0E0      		ldi r31,hi8(matrix)
  96 0018 85E0      		ldi r24,lo8(5)
  97 001a 8E0F      		add r24,r30
  98               	.LVL2:
  99               	.L5:
 100               	.LBE24:
 101               	.LBE23:
 102               	.LBB25:
  66:matrix.c      ****         matrix_debouncing[i] = 0;
 103               		.loc 1 66 0 discriminator 3
 104 001c 1192      		st Z+,__zero_reg__
 105               	.LVL3:
  67:matrix.c      ****     }
 106               		.loc 1 67 0 discriminator 3
 107 001e 1D92      		st X+,__zero_reg__
 108               	.LVL4:
  65:matrix.c      ****         matrix[i] = 0;
 109               		.loc 1 65 0 discriminator 3
 110 0020 8E13      		cpse r24,r30
 111 0022 00C0      		rjmp .L5
 112               	/* epilogue start */
 113               	.LBE25:
  69:matrix.c      **** 
 114               		.loc 1 69 0
 115 0024 0895      		ret
 116               		.cfi_endproc
 117               	.LFE9:
 119               		.section	.text.matrix_scan,"ax",@progbits
 120               	.global	matrix_scan
 122               	matrix_scan:
 123               	.LFB10:
  72:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 124               		.loc 1 72 0
 125               		.cfi_startproc
 126 0000 DF92      		push r13
 127               	.LCFI0:
 128               		.cfi_def_cfa_offset 3
 129               		.cfi_offset 13, -2
 130 0002 EF92      		push r14
 131               	.LCFI1:
 132               		.cfi_def_cfa_offset 4
 133               		.cfi_offset 14, -3
 134 0004 FF92      		push r15
 135               	.LCFI2:
 136               		.cfi_def_cfa_offset 5
 137               		.cfi_offset 15, -4
 138 0006 0F93      		push r16
 139               	.LCFI3:
 140               		.cfi_def_cfa_offset 6
 141               		.cfi_offset 16, -5
 142 0008 1F93      		push r17
 143               	.LCFI4:
 144               		.cfi_def_cfa_offset 7
 145               		.cfi_offset 17, -6
 146 000a CF93      		push r28
 147               	.LCFI5:
 148               		.cfi_def_cfa_offset 8
 149               		.cfi_offset 28, -7
 150 000c DF93      		push r29
 151               	.LCFI6:
 152               		.cfi_def_cfa_offset 9
 153               		.cfi_offset 29, -8
 154               	/* prologue: function */
 155               	/* frame size = 0 */
 156               	/* stack size = 7 */
 157               	.L__stack_usage = 7
 158               	.LVL5:
  72:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 159               		.loc 1 72 0
 160 000e 00E0      		ldi r16,lo8(matrix_debouncing)
 161 0010 10E0      		ldi r17,hi8(matrix_debouncing)
 162               	.LBB40:
  73:matrix.c      ****         select_row(i);
 163               		.loc 1 73 0
 164 0012 C0E0      		ldi r28,0
 165 0014 D1E0      		ldi r29,lo8(1)
 166               	.LBB41:
  82:matrix.c      ****         }
 167               		.loc 1 82 0
 168 0016 85E0      		ldi r24,lo8(5)
 169 0018 D82E      		mov r13,r24
  80:matrix.c      ****             }
 170               		.loc 1 80 0
 171 001a 90E0      		ldi r25,lo8(__c.1909)
 172 001c E92E      		mov r14,r25
 173 001e 90E0      		ldi r25,hi8(__c.1909)
 174 0020 F92E      		mov r15,r25
 175               	.LVL6:
 176               	.L26:
 177               	.LBB42:
 178               	.LBB43:
 167:matrix.c      **** }
 168:matrix.c      **** 
 169:matrix.c      **** static void select_row(uint8_t row)
 170:matrix.c      **** {
 171:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 172:matrix.c      ****     switch (row) {
 179               		.loc 1 172 0
 180 0022 C230      		cpi r28,lo8(2)
 181 0024 01F0      		breq .L10
 182 0026 00F4      		brsh .L11
 183 0028 C130      		cpi r28,lo8(1)
 184 002a 01F0      		breq .L12
 185 002c 00C0      		rjmp .L9
 186               	.L11:
 187 002e C330      		cpi r28,lo8(3)
 188 0030 01F0      		breq .L13
 189 0032 C430      		cpi r28,lo8(4)
 190 0034 01F0      		breq .L14
 191               	.L9:
 173:matrix.c      ****         case 0:
 174:matrix.c      ****             DDRD  |= (1<<0);
 192               		.loc 1 174 0
 193 0036 509A      		sbi 0xa,0
 175:matrix.c      ****             PORTD &= ~(1<<0);
 194               		.loc 1 175 0
 195 0038 5898      		cbi 0xb,0
 196 003a 00C0      		rjmp .L15
 197               	.L12:
 176:matrix.c      ****             break;
 177:matrix.c      ****         case 1:
 178:matrix.c      ****             DDRD  |= (1<<1);
 198               		.loc 1 178 0
 199 003c 519A      		sbi 0xa,1
 179:matrix.c      ****             PORTD &= ~(1<<1);
 200               		.loc 1 179 0
 201 003e 5998      		cbi 0xb,1
 202 0040 00C0      		rjmp .L15
 203               	.L10:
 180:matrix.c      ****             break;
 181:matrix.c      ****         case 2:
 182:matrix.c      ****             DDRD  |= (1<<2);
 204               		.loc 1 182 0
 205 0042 529A      		sbi 0xa,2
 183:matrix.c      ****             PORTD &= ~(1<<2);
 206               		.loc 1 183 0
 207 0044 5A98      		cbi 0xb,2
 208 0046 00C0      		rjmp .L15
 209               	.L13:
 184:matrix.c      ****             break;
 185:matrix.c      ****         case 3:
 186:matrix.c      ****             DDRD  |= (1<<3);
 210               		.loc 1 186 0
 211 0048 539A      		sbi 0xa,3
 187:matrix.c      ****             PORTD &= ~(1<<3);
 212               		.loc 1 187 0
 213 004a 5B98      		cbi 0xb,3
 214 004c 00C0      		rjmp .L15
 215               	.L14:
 188:matrix.c      ****             break;
 189:matrix.c      ****         case 4:
 190:matrix.c      ****             DDRD  |= (1<<4);
 216               		.loc 1 190 0
 217 004e 549A      		sbi 0xa,4
 191:matrix.c      ****             PORTD &= ~(1<<4);
 218               		.loc 1 191 0
 219 0050 5C98      		cbi 0xb,4
 220               	.L15:
 221               	.LVL7:
 222               	.LBE43:
 223               	.LBE42:
 224               	.LBB44:
 225               	.LBB45:
 226               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 227               		.loc 2 245 0
 228 0052 80EA      		ldi r24,lo8(-96)
 229 0054 8A95      	1:	dec r24
 230 0056 01F4      		brne 1b
 231               	.LBE45:
 232               	.LBE44:
 233               	.LBB46:
 234               	.LBB47:
 151:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<1)) |
 235               		.loc 1 151 0
 236 0058 83B1      		in r24,0x3
 237 005a 8170      		andi r24,lo8(1)
 238 005c 8D27      		eor r24,r29
 239 005e 1999      		sbic 0x3,1
 240 0060 00C0      		rjmp .L32
 241 0062 92E0      		ldi r25,lo8(2)
 242 0064 00C0      		rjmp .L16
 243               	.L32:
 244 0066 90E0      		ldi r25,0
 245               	.L16:
 246 0068 892B      		or r24,r25
 247 006a 1D99      		sbic 0x3,5
 248 006c 00C0      		rjmp .L33
 249 006e 94E0      		ldi r25,lo8(4)
 250 0070 00C0      		rjmp .L17
 251               	.L33:
 252 0072 90E0      		ldi r25,0
 253               	.L17:
 254 0074 892B      		or r24,r25
 255 0076 1B99      		sbic 0x3,3
 256 0078 00C0      		rjmp .L34
 257 007a 98E0      		ldi r25,lo8(8)
 258 007c 00C0      		rjmp .L18
 259               	.L34:
 260 007e 90E0      		ldi r25,0
 261               	.L18:
 262 0080 892B      		or r24,r25
 263 0082 1C99      		sbic 0x3,4
 264 0084 00C0      		rjmp .L35
 265 0086 90E1      		ldi r25,lo8(16)
 266 0088 00C0      		rjmp .L19
 267               	.L35:
 268 008a 90E0      		ldi r25,0
 269               	.L19:
 270 008c 892B      		or r24,r25
 271               	.LBE47:
 272               	.LBE46:
  77:matrix.c      ****             matrix_debouncing[i] = cols;
 273               		.loc 1 77 0
 274 008e F801      		movw r30,r16
 275 0090 9081      		ld r25,Z
 276 0092 9817      		cp r25,r24
 277 0094 01F0      		breq .L20
  78:matrix.c      ****             if (debouncing) {
 278               		.loc 1 78 0
 279 0096 8083      		st Z,r24
  79:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 280               		.loc 1 79 0
 281 0098 8091 0000 		lds r24,debouncing
 282 009c 8823      		tst r24
 283 009e 01F0      		breq .L22
  80:matrix.c      ****             }
 284               		.loc 1 80 0
 285 00a0 8091 0000 		lds r24,debug_config
 286 00a4 80FF      		sbrs r24,0
 287 00a6 00C0      		rjmp .L23
  80:matrix.c      ****             }
 288               		.loc 1 80 0 is_stmt 0 discriminator 1
 289 00a8 80E0      		ldi r24,lo8(__c.1907)
 290 00aa 90E0      		ldi r25,hi8(__c.1907)
 291 00ac 0E94 0000 		call xputs
 292               	.LVL8:
 293               	.L23:
  80:matrix.c      ****             }
 294               		.loc 1 80 0 discriminator 3
 295 00b0 8091 0000 		lds r24,debug_config
 296 00b4 80FF      		sbrs r24,0
 297 00b6 00C0      		rjmp .L24
  80:matrix.c      ****             }
 298               		.loc 1 80 0 discriminator 4
 299 00b8 8091 0000 		lds r24,debouncing
 300 00bc 1F92      		push __zero_reg__
 301               	.LCFI7:
 302               		.cfi_def_cfa_offset 10
 303 00be 8F93      		push r24
 304               	.LCFI8:
 305               		.cfi_def_cfa_offset 11
 306 00c0 FF92      		push r15
 307               	.LCFI9:
 308               		.cfi_def_cfa_offset 12
 309 00c2 EF92      		push r14
 310               	.LCFI10:
 311               		.cfi_def_cfa_offset 13
 312 00c4 0E94 0000 		call __xprintf
 313               	.LVL9:
 314 00c8 0F90      		pop __tmp_reg__
 315 00ca 0F90      		pop __tmp_reg__
 316 00cc 0F90      		pop __tmp_reg__
 317 00ce 0F90      		pop __tmp_reg__
 318               	.LCFI11:
 319               		.cfi_def_cfa_offset 9
 320               	.L24:
  80:matrix.c      ****             }
 321               		.loc 1 80 0 discriminator 6
 322 00d0 8091 0000 		lds r24,debug_config
 323 00d4 80FF      		sbrs r24,0
 324 00d6 00C0      		rjmp .L22
  80:matrix.c      ****             }
 325               		.loc 1 80 0 discriminator 7
 326 00d8 80E0      		ldi r24,lo8(__c.1911)
 327 00da 90E0      		ldi r25,hi8(__c.1911)
 328 00dc 0E94 0000 		call xputs
 329               	.LVL10:
 330               	.L22:
  82:matrix.c      ****         }
 331               		.loc 1 82 0 is_stmt 1
 332 00e0 D092 0000 		sts debouncing,r13
 333               	.L20:
  84:matrix.c      ****     }
 334               		.loc 1 84 0 discriminator 2
 335 00e4 0E94 0000 		call unselect_rows
 336               	.LVL11:
 337               	.LBE41:
  73:matrix.c      ****         select_row(i);
 338               		.loc 1 73 0 discriminator 2
 339 00e8 CF5F      		subi r28,lo8(-(1))
 340               	.LVL12:
 341 00ea 0F5F      		subi r16,-1
 342 00ec 1F4F      		sbci r17,-1
 343 00ee C530      		cpi r28,lo8(5)
 344 00f0 01F0      		breq .+2
 345 00f2 00C0      		rjmp .L26
 346               	.LBE40:
  87:matrix.c      ****         if (--debouncing) {
 347               		.loc 1 87 0
 348 00f4 8091 0000 		lds r24,debouncing
 349 00f8 8823      		tst r24
 350 00fa 01F0      		breq .L28
  88:matrix.c      ****             _delay_ms(1);
 351               		.loc 1 88 0
 352 00fc 8150      		subi r24,lo8(-(-1))
 353 00fe 8093 0000 		sts debouncing,r24
 354 0102 8823      		tst r24
 355 0104 01F0      		breq .L29
 356               	.LVL13:
 357               	.LBB48:
 358               	.LBB49:
 163:/usr/lib/avr/include/util/delay.h **** 
 359               		.loc 2 163 0
 360 0106 8FE9      		ldi r24,lo8(3999)
 361 0108 9FE0      		ldi r25,hi8(3999)
 362 010a 0197      	1:	sbiw r24,1
 363 010c 01F4      		brne 1b
 364 010e 00C0      		rjmp .
 365 0110 0000      		nop
 366 0112 00C0      		rjmp .L28
 367               	.LVL14:
 368               	.L29:
 369 0114 A0E0      		ldi r26,lo8(matrix)
 370 0116 B0E0      		ldi r27,hi8(matrix)
 371               	.LBE49:
 372               	.LBE48:
  88:matrix.c      ****             _delay_ms(1);
 373               		.loc 1 88 0
 374 0118 E0E0      		ldi r30,lo8(matrix_debouncing)
 375 011a F0E0      		ldi r31,hi8(matrix_debouncing)
 376 011c CF01      		movw r24,r30
 377 011e 8B5F      		subi r24,lo8(-(5))
 378               	.L30:
 379               	.LVL15:
 380               	.LBB50:
  92:matrix.c      ****             }
 381               		.loc 1 92 0 discriminator 3
 382 0120 9191      		ld r25,Z+
 383               	.LVL16:
 384 0122 9D93      		st X+,r25
 385               	.LVL17:
  91:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 386               		.loc 1 91 0 discriminator 3
 387 0124 8E13      		cpse r24,r30
 388 0126 00C0      		rjmp .L30
 389               	.LVL18:
 390               	.L28:
 391               	.LBE50:
  98:matrix.c      **** 
 392               		.loc 1 98 0
 393 0128 81E0      		ldi r24,lo8(1)
 394               	/* epilogue start */
 395 012a DF91      		pop r29
 396 012c CF91      		pop r28
 397               	.LVL19:
 398 012e 1F91      		pop r17
 399 0130 0F91      		pop r16
 400 0132 FF90      		pop r15
 401 0134 EF90      		pop r14
 402 0136 DF90      		pop r13
 403 0138 0895      		ret
 404               		.cfi_endproc
 405               	.LFE10:
 407               		.section	.text.matrix_is_modified,"ax",@progbits
 408               	.global	matrix_is_modified
 410               	matrix_is_modified:
 411               	.LFB11:
 101:matrix.c      ****     if (debouncing) return false;
 412               		.loc 1 101 0
 413               		.cfi_startproc
 414               	/* prologue: function */
 415               	/* frame size = 0 */
 416               	/* stack size = 0 */
 417               	.L__stack_usage = 0
 102:matrix.c      ****     return true;
 418               		.loc 1 102 0
 419 0000 81E0      		ldi r24,lo8(1)
 420 0002 9091 0000 		lds r25,debouncing
 421 0006 9111      		cpse r25,__zero_reg__
 422 0008 80E0      		ldi r24,0
 423               	.L48:
 104:matrix.c      **** 
 424               		.loc 1 104 0
 425 000a 0895      		ret
 426               		.cfi_endproc
 427               	.LFE11:
 429               		.section	.text.matrix_is_on,"ax",@progbits
 430               	.global	matrix_is_on
 432               	matrix_is_on:
 433               	.LFB12:
 108:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 434               		.loc 1 108 0
 435               		.cfi_startproc
 436               	.LVL20:
 437               	/* prologue: function */
 438               	/* frame size = 0 */
 439               	/* stack size = 0 */
 440               	.L__stack_usage = 0
 109:matrix.c      **** }
 441               		.loc 1 109 0
 442 0000 E82F      		mov r30,r24
 443 0002 F0E0      		ldi r31,0
 444 0004 E050      		subi r30,lo8(-(matrix))
 445 0006 F040      		sbci r31,hi8(-(matrix))
 446 0008 2081      		ld r18,Z
 447 000a 822F      		mov r24,r18
 448               	.LVL21:
 449 000c 90E0      		ldi r25,0
 450 000e 21E0      		ldi r18,lo8(1)
 451 0010 30E0      		ldi r19,0
 452 0012 00C0      		rjmp 2f
 453               		1:
 454 0014 220F      		lsl r18
 455 0016 331F      		rol r19
 456               		2:
 457 0018 6A95      		dec r22
 458 001a 02F4      		brpl 1b
 459 001c 2823      		and r18,r24
 460 001e 3923      		and r19,r25
 461 0020 81E0      		ldi r24,lo8(1)
 462 0022 232B      		or r18,r19
 463 0024 01F4      		brne .L53
 464 0026 80E0      		ldi r24,0
 465               	.L53:
 110:matrix.c      **** 
 466               		.loc 1 110 0
 467 0028 0895      		ret
 468               		.cfi_endproc
 469               	.LFE12:
 471               		.section	.text.matrix_get_row,"ax",@progbits
 472               	.global	matrix_get_row
 474               	matrix_get_row:
 475               	.LFB13:
 114:matrix.c      ****     return matrix[row];
 476               		.loc 1 114 0
 477               		.cfi_startproc
 478               	.LVL22:
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481               	/* stack size = 0 */
 482               	.L__stack_usage = 0
 115:matrix.c      **** }
 483               		.loc 1 115 0
 484 0000 E82F      		mov r30,r24
 485 0002 F0E0      		ldi r31,0
 486 0004 E050      		subi r30,lo8(-(matrix))
 487 0006 F040      		sbci r31,hi8(-(matrix))
 116:matrix.c      **** 
 488               		.loc 1 116 0
 489 0008 8081      		ld r24,Z
 490               	.LVL23:
 491 000a 0895      		ret
 492               		.cfi_endproc
 493               	.LFE13:
 495               		.section	.text.matrix_print,"ax",@progbits
 496               	.global	matrix_print
 498               	matrix_print:
 499               	.LFB14:
 119:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 500               		.loc 1 119 0
 501               		.cfi_startproc
 502 0000 CF92      		push r12
 503               	.LCFI12:
 504               		.cfi_def_cfa_offset 3
 505               		.cfi_offset 12, -2
 506 0002 DF92      		push r13
 507               	.LCFI13:
 508               		.cfi_def_cfa_offset 4
 509               		.cfi_offset 13, -3
 510 0004 EF92      		push r14
 511               	.LCFI14:
 512               		.cfi_def_cfa_offset 5
 513               		.cfi_offset 14, -4
 514 0006 FF92      		push r15
 515               	.LCFI15:
 516               		.cfi_def_cfa_offset 6
 517               		.cfi_offset 15, -5
 518 0008 0F93      		push r16
 519               	.LCFI16:
 520               		.cfi_def_cfa_offset 7
 521               		.cfi_offset 16, -6
 522 000a 1F93      		push r17
 523               	.LCFI17:
 524               		.cfi_def_cfa_offset 8
 525               		.cfi_offset 17, -7
 526 000c CF93      		push r28
 527               	.LCFI18:
 528               		.cfi_def_cfa_offset 9
 529               		.cfi_offset 28, -8
 530 000e DF93      		push r29
 531               	.LCFI19:
 532               		.cfi_def_cfa_offset 10
 533               		.cfi_offset 29, -9
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 8 */
 537               	.L__stack_usage = 8
 120:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 538               		.loc 1 120 0
 539 0010 80E0      		ldi r24,lo8(__c.1933)
 540 0012 90E0      		ldi r25,hi8(__c.1933)
 541 0014 0E94 0000 		call xputs
 542 0018 80E0      		ldi r24,lo8(matrix)
 543 001a E82E      		mov r14,r24
 544 001c 80E0      		ldi r24,hi8(matrix)
 545 001e F82E      		mov r15,r24
 546 0020 C0E0      		ldi r28,0
 547 0022 D0E0      		ldi r29,0
 548               	.LBB51:
 122:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 549               		.loc 1 122 0
 550 0024 90E0      		ldi r25,lo8(__c.1936)
 551 0026 C92E      		mov r12,r25
 552 0028 90E0      		ldi r25,hi8(__c.1936)
 553 002a D92E      		mov r13,r25
 123:matrix.c      ****         print("\n");
 554               		.loc 1 123 0
 555 002c 00E0      		ldi r16,lo8(__c.1940)
 556 002e 10E0      		ldi r17,hi8(__c.1940)
 557               	.L56:
 122:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 558               		.loc 1 122 0 discriminator 3
 559 0030 DF93      		push r29
 560               	.LCFI20:
 561               		.cfi_def_cfa_offset 11
 562 0032 CF93      		push r28
 563               	.LCFI21:
 564               		.cfi_def_cfa_offset 12
 565 0034 DF92      		push r13
 566               	.LCFI22:
 567               		.cfi_def_cfa_offset 13
 568 0036 CF92      		push r12
 569               	.LCFI23:
 570               		.cfi_def_cfa_offset 14
 571 0038 0E94 0000 		call __xprintf
 572 003c 80E0      		ldi r24,lo8(__c.1938)
 573 003e 90E0      		ldi r25,hi8(__c.1938)
 574 0040 0E94 0000 		call xputs
 575               	.LBB52:
 576               	.LBB53:
 115:matrix.c      **** }
 577               		.loc 1 115 0 discriminator 3
 578 0044 F701      		movw r30,r14
 579 0046 8191      		ld r24,Z+
 580 0048 7F01      		movw r14,r30
 581               	.LBE53:
 582               	.LBE52:
 123:matrix.c      ****         print("\n");
 583               		.loc 1 123 0 discriminator 3
 584 004a 90E0      		ldi r25,0
 585 004c 0E94 0000 		call bitrev16
 586 0050 9F93      		push r25
 587               	.LCFI24:
 588               		.cfi_def_cfa_offset 15
 589 0052 8F93      		push r24
 590               	.LCFI25:
 591               		.cfi_def_cfa_offset 16
 592 0054 1F93      		push r17
 593               	.LCFI26:
 594               		.cfi_def_cfa_offset 17
 595 0056 0F93      		push r16
 596               	.LCFI27:
 597               		.cfi_def_cfa_offset 18
 598 0058 0E94 0000 		call __xprintf
 124:matrix.c      ****     }
 599               		.loc 1 124 0 discriminator 3
 600 005c 80E0      		ldi r24,lo8(__c.1942)
 601 005e 90E0      		ldi r25,hi8(__c.1942)
 602 0060 0E94 0000 		call xputs
 603 0064 2196      		adiw r28,1
 121:matrix.c      ****         phex(row); print(": ");
 604               		.loc 1 121 0 discriminator 3
 605 0066 8DB7      		in r24,__SP_L__
 606 0068 9EB7      		in r25,__SP_H__
 607 006a 0896      		adiw r24,8
 608 006c 0FB6      		in __tmp_reg__,__SREG__
 609 006e F894      		cli
 610 0070 9EBF      		out __SP_H__,r25
 611 0072 0FBE      		out __SREG__,__tmp_reg__
 612 0074 8DBF      		out __SP_L__,r24
 613               	.LCFI28:
 614               		.cfi_def_cfa_offset 10
 615 0076 C530      		cpi r28,5
 616 0078 D105      		cpc r29,__zero_reg__
 617 007a 01F4      		brne .L56
 618               	/* epilogue start */
 619               	.LBE51:
 126:matrix.c      **** 
 620               		.loc 1 126 0
 621 007c DF91      		pop r29
 622 007e CF91      		pop r28
 623 0080 1F91      		pop r17
 624 0082 0F91      		pop r16
 625 0084 FF90      		pop r15
 626 0086 EF90      		pop r14
 627 0088 DF90      		pop r13
 628 008a CF90      		pop r12
 629 008c 0895      		ret
 630               		.cfi_endproc
 631               	.LFE14:
 633               		.section	.text.matrix_key_count,"ax",@progbits
 634               	.global	matrix_key_count
 636               	matrix_key_count:
 637               	.LFB15:
 129:matrix.c      ****     uint8_t count = 0;
 638               		.loc 1 129 0
 639               		.cfi_startproc
 640 0000 0F93      		push r16
 641               	.LCFI29:
 642               		.cfi_def_cfa_offset 3
 643               		.cfi_offset 16, -2
 644 0002 1F93      		push r17
 645               	.LCFI30:
 646               		.cfi_def_cfa_offset 4
 647               		.cfi_offset 17, -3
 648 0004 CF93      		push r28
 649               	.LCFI31:
 650               		.cfi_def_cfa_offset 5
 651               		.cfi_offset 28, -4
 652 0006 DF93      		push r29
 653               	.LCFI32:
 654               		.cfi_def_cfa_offset 6
 655               		.cfi_offset 29, -5
 656               	/* prologue: function */
 657               	/* frame size = 0 */
 658               	/* stack size = 4 */
 659               	.L__stack_usage = 4
 660               	.LVL24:
 129:matrix.c      ****     uint8_t count = 0;
 661               		.loc 1 129 0
 662 0008 C0E0      		ldi r28,lo8(matrix)
 663 000a D0E0      		ldi r29,hi8(matrix)
 130:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 664               		.loc 1 130 0
 665 000c 10E0      		ldi r17,0
 666 000e 0C2F      		mov r16,r28
 667 0010 0B5F      		subi r16,lo8(-(5))
 668               	.LVL25:
 669               	.L59:
 670               	.LBB54:
 132:matrix.c      ****     }
 671               		.loc 1 132 0 discriminator 3
 672 0012 8991      		ld r24,Y+
 673               	.LVL26:
 674 0014 90E0      		ldi r25,0
 675 0016 0E94 0000 		call bitpop16
 676               	.LVL27:
 677 001a 180F      		add r17,r24
 678               	.LVL28:
 131:matrix.c      ****         count += bitpop16(matrix[i]);
 679               		.loc 1 131 0 discriminator 3
 680 001c 0C13      		cpse r16,r28
 681 001e 00C0      		rjmp .L59
 682               	.LBE54:
 135:matrix.c      **** 
 683               		.loc 1 135 0
 684 0020 812F      		mov r24,r17
 685               	/* epilogue start */
 686 0022 DF91      		pop r29
 687 0024 CF91      		pop r28
 688               	.LVL29:
 689 0026 1F91      		pop r17
 690               	.LVL30:
 691 0028 0F91      		pop r16
 692 002a 0895      		ret
 693               		.cfi_endproc
 694               	.LFE15:
 696               		.section	.progmem.data.__c.1942,"a",@progbits
 699               	__c.1942:
 700 0000 0A00      		.string	"\n"
 701               		.section	.progmem.data.__c.1940,"a",@progbits
 704               	__c.1940:
 705 0000 2530 3136 		.string	"%016b"
 705      6200 
 706               		.section	.progmem.data.__c.1938,"a",@progbits
 709               	__c.1938:
 710 0000 3A20 00   		.string	": "
 711               		.section	.progmem.data.__c.1936,"a",@progbits
 714               	__c.1936:
 715 0000 2530 3258 		.string	"%02X"
 715      00
 716               		.section	.progmem.data.__c.1933,"a",@progbits
 719               	__c.1933:
 720 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 720      2030 3132 
 720      3334 3536 
 720      3738 3941 
 720      4243 4445 
 721               		.section	.progmem.data.__c.1911,"a",@progbits
 724               	__c.1911:
 725 0000 0A00      		.string	"\n"
 726               		.section	.progmem.data.__c.1909,"a",@progbits
 729               	__c.1909:
 730 0000 2530 3258 		.string	"%02X"
 730      00
 731               		.section	.progmem.data.__c.1907,"a",@progbits
 734               	__c.1907:
 735 0000 626F 756E 		.string	"bounce!: "
 735      6365 213A 
 735      2000 
 736               		.section	.bss.matrix_debouncing,"aw",@nobits
 739               	matrix_debouncing:
 740 0000 0000 0000 		.zero	5
 740      00
 741               		.section	.bss.matrix,"aw",@nobits
 744               	matrix:
 745 0000 0000 0000 		.zero	5
 745      00
 746               		.section	.data.debouncing,"aw",@progbits
 749               	debouncing:
 750 0000 05        		.byte	5
 751               		.text
 752               	.Letext0:
 753               		.file 3 "/usr/lib/avr/include/stdint.h"
 754               		.file 4 "../../tmk_core/common/debug.h"
 755               		.file 5 "../../tmk_core/common/matrix.h"
 756               		.file 6 "../../tmk_core/common/avr/xprintf.h"
 757               		.file 7 "../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccEuhmt5.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccEuhmt5.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccEuhmt5.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccEuhmt5.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccEuhmt5.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccEuhmt5.s:12     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccEuhmt5.s:36     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccEuhmt5.s:53     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccEuhmt5.s:70     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccEuhmt5.s:739    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccEuhmt5.s:744    .bss.matrix:0000000000000000 matrix
     /tmp/ccEuhmt5.s:122    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccEuhmt5.s:729    .progmem.data.__c.1909:0000000000000000 __c.1909
     /tmp/ccEuhmt5.s:749    .data.debouncing:0000000000000000 debouncing
     /tmp/ccEuhmt5.s:734    .progmem.data.__c.1907:0000000000000000 __c.1907
     /tmp/ccEuhmt5.s:724    .progmem.data.__c.1911:0000000000000000 __c.1911
     /tmp/ccEuhmt5.s:410    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccEuhmt5.s:432    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccEuhmt5.s:474    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccEuhmt5.s:498    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccEuhmt5.s:719    .progmem.data.__c.1933:0000000000000000 __c.1933
     /tmp/ccEuhmt5.s:714    .progmem.data.__c.1936:0000000000000000 __c.1936
     /tmp/ccEuhmt5.s:704    .progmem.data.__c.1940:0000000000000000 __c.1940
     /tmp/ccEuhmt5.s:709    .progmem.data.__c.1938:0000000000000000 __c.1938
     /tmp/ccEuhmt5.s:699    .progmem.data.__c.1942:0000000000000000 __c.1942
     /tmp/ccEuhmt5.s:636    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
